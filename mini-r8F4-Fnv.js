function j(e, t, r, n) { let a = r.length, s = /[:,@]\S*=/.exec(e); if (!s) return console.error("MiNi: attribute is missing :@ prefix", e), !1; if (s?.length > 1) return console.error('MiNi: attribute is missing "${}"', e), !1; if (!e.endsWith(s[0] + '"')) return console.error("MiNi: attribute " + s[0] + ' is missing "${}"'), !1; const c = s[0][0], o = s[0].slice(1, -1); r.push({ type: c, key: o, v: t }); const i = e.lastIndexOf(o); return e = e.substring(0, i - 1) + e.substring(i - 1).replace(c + o, o + a), e.slice(-1) === '"' ? n.push("") : n.push('""'), e } function F(e, ...t) { let r = [...e]; function n(a) { let s = [], c = [], o = !1; for (let l = 0; l < t.length; l++) { const u = t[l], b = r[l], g = b.lastIndexOf("<"), S = b.lastIndexOf(">"); o = g !== -1 && g > S ? !0 : o, o = S !== -1 && S > g ? !1 : o; const M = c.length; if (typeof u == "function" || u instanceof Promise || u?.signal) if (!o) c.push({ type: "node", key: M, v: u }), s[l] = `<!--rx${M}-->`; else { const v = j(r[l], u, c, s); v ? r[l] = v : console.error("MiNi: unknown attribute type", r[l], u) } else Array.isArray(u) ? (s[l] = "", u.forEach((v, P) => { typeof v == "function" ? (c.push({ type: "node", key: M + ":" + P, v }), s[l] += `<!--rx${M}:${P}-->`) : s[l] += v })) : u === !1 || u === void 0 ? (o && r[l].slice(-1) === '"' && (r[l] = r[l].replace(/\s(\S+)$/, '"')), s.push("")) : s.push(u) } function i(l, u) { let b = l[0]; for (let g = 0; g < u.length; g++)b += u[g] + l[g + 1]; return b.replace(/\s+/g, " ") } let p = i(r, s); return p = p.replace(/(?=\/\*).*?(?:\*\/)/g, ""), { html: p.trim(), reactarray: c } } return n.html = !0, n } let d, h = null, f = 0, N = [], k, _ = !1; const A = 0, q = 1, m = 2; function O(e, t) { const r = new L(e, t?.effect, t?.label); return t?.equals && (r.equals = t.equals), r.signal = !0, r } function W(e, t) { return e === t } class L { _value; fn; observers = null; sources = null; state; effect; label; cleanups = []; equals = W; constructor(t, r, n) { typeof t == "function" ? (this.fn = t, this._value = void 0, this.effect = r || !1, this.state = m, r && (N.push(this), k?.(this))) : (this.fn = void 0, this._value = t, this.state = A, this.effect = !1), n && (this.label = n) } get value() { return this.get() } set value(t) { this.set(t) } get() { return d && (!h && d.sources && d.sources[f] == this ? f++ : h ? h.push(this) : h = [this]), this.fn && this.updateIfNecessary(), this._value } set(t) { if (typeof t == "function") { const r = t; r !== this.fn && this.stale(m), this.fn = r } else { this.fn && (this.removeParentObservers(0), this.sources = null, this.fn = void 0); const r = t; if (!this.equals(this._value, r)) { if (this.observers) for (let n = 0; n < this.observers.length; n++)this.observers[n].stale(m); this._value = r } } } stale(t) { if (this.state < t && (this.state === A && this.effect && (N.push(this), k?.(this)), this.state = t, this.observers)) for (let r = 0; r < this.observers.length; r++)this.observers[r].stale(q) } update() { const t = this._value, r = d, n = h, a = f; d = this, h = null, f = 0; try { if (this.cleanups.length && (this.cleanups.forEach(s => s(this._value)), this.cleanups = []), this._value = this.fn(), h) { if (this.removeParentObservers(f), this.sources && f > 0) { this.sources.length = f + h.length; for (let s = 0; s < h.length; s++)this.sources[f + s] = h[s] } else this.sources = h; for (let s = f; s < this.sources.length; s++) { const c = this.sources[s]; c.observers ? c.observers.push(this) : c.observers = [this] } } else this.sources && f < this.sources.length && (this.removeParentObservers(f), this.sources.length = f) } finally { h = n, d = r, f = a } if (!this.equals(t, this._value) && this.observers) for (let s = 0; s < this.observers.length; s++) { const c = this.observers[s]; c.state = m } this.state = A } updateIfNecessary() { if (this.state === q) { for (const t of this.sources) if (t.updateIfNecessary(), this.state === m) break } this.state === m && this.update(), this.state = A } removeParentObservers(t) { if (this.sources) for (let r = t; r < this.sources.length; r++) { const n = this.sources[r], a = n.observers.findIndex(s => s === this); n.observers[a] = n.observers[n.observers.length - 1], n.observers.pop() } } } function B(e) { const t = d, r = h, n = f; d = void 0, h = null, f = 0; const a = e(); return h = r, d = t, f = n, a } function G() { for (let e = 0; e < N.length; e++)N[e].get(); N.length = 0 } function H(e = J) { k = e } H(); function J() { _ || (_ = !0, queueMicrotask(() => { _ = !1, G() })) } function E(e) { if (e.nodeType) { let t = [e]; return t.parent = e.parentNode, t.next = e.nextSibling, t.prev = e.previousSibling, t.fragment = !0, t } else return Array.isArray(e) && !e.fragment ? e[0] ? (e[0].before(document.createTextNode("")), e[e.length - 1].after(document.createTextNode("")), e.parent = e[0].parentNode, e.prev = e[0].previousSibling, e.next = e[e.length - 1].nextSibling, e.fragment = !0, e) : !1 : (console.error("MiNi: unknown input for createFragment"), !1) } function K(e, t) { return e.fragment && Array.isArray(e) && Array.isArray(t) ? (t.prev = e.prev, t.next = e.next, t.parent = e.parent, w(e), t.next ? t.next.before(...t) : t.parent.append(...t), t.fragment = !0) : console.error("MiNi: replaceFragments unknown input", e, t), t } function w(e) { if (!e.prev && !e.next && e.parent) e.parent.textContent = ""; else { if (e.prev?.nextSibling === e.next) return e; { let t = e.prev?.nextSibling || e.next?.parentElement?.firstChild || e.parent?.firstChild; if (!t) return; for (; t !== e.next;) { if (!t) return console.error("MiNi: clearFragment missing node", e); const r = t.nextSibling; t.remove(), t = r } } } return e.length && e.splice(0, e.length), e } let y = []; function Z(e) { y.push(e) } let x = []; function z(e) { x.push(e) } function T(e, t = []) { return e.unmount && (t.push(e.unmount), delete e.unmount), Object.getOwnPropertySymbols(e).forEach(r => { e[r]?.frag && T(e[r], t) }), t.flat().reverse() } function Q(e, t) { const r = document.createComment("rx"); let n = new Array(e.length); n = n.fill(0).map(() => r.cloneNode()), t.frag = K(t.frag, n); for (let a = 0; a < e.length; a++)I(n[a], () => e[a], t) } function U(e, t) { if (t.hidden && (t.hidden = !1), e?.html) $(t.frag, e, t), t.mount && setTimeout(() => { t.mount?.forEach(r => r()), t.mount = void 0 }, 0); else if (Array.isArray(e)) Q(e, t), t.mount && setTimeout(() => { t.mount?.forEach(r => r()), t.mount = void 0 }, 0); else if (e === !1 || e === "") w(t.frag), t.hidden = !0; else { let r = t.frag.prev.nextSibling; if (r.nodeType !== 3) { const n = document.createTextNode(""); r.replaceWith(n), r = n } e !== void 0 && r.data !== e && (r.data = e) } } function V(e) { const t = Object.getOwnPropertySymbols(e).filter(n => e[n]?.loader)?.[0]; if (!t) return; const r = e[t].frag; w(r), delete e[t] } function C(e) { Object.getOwnPropertySymbols(e).forEach(t => { e[t]?.frag && (e[t].stale = !0, C(e[t]), delete e[t]) }) } function I(e, t, r) { const n = Symbol("$comp"); if (r[n] = {}, e.before(document.createTextNode("")), e.after(document.createTextNode("")), r[n].frag = E(e), t._map) return t(r, n); O(async () => { if (!r[n]) return; if (r.stale || r[n].stale) return delete r[n]; C(r[n]); const a = y.length, s = x.length, c = T(r[n]); c.length && c.forEach(i => typeof i == "function" && i()); let o = t(); if (o instanceof Promise && (o = await o), y.length > a) { const i = y.length - a; r[n].mount = y.splice(-i, i) } if (x.length > s) { const i = x.length - s; r[n].unmount = x.splice(-i, i) } if (typeof o == "function" && o?._map) return o(r, n); t._loader && (r[n].loader = !0), t._suspense && (r[n].suspense = !0, V(r), delete t._suspense), o = typeof o == "function" ? B(o) : o, U(o, r[n]) }, { effect: !0 }) } function X(e, t, r, n) { function a(o, i, p) { p === !0 ? o.setAttribute(i, i) : p === !1 ? o.removeAttribute(i) : p !== !1 && p != null && o.setAttribute(i, p) } const s = Symbol("$attr"); n[s] = {}, n[s].frag = E(e); const c = O(r); O(() => { if (!n[s]) return; if (n.stale || n[s].stale) return delete n[s]; let o = c.value; t === "value" ? o.signal ? e.value = o.value : e.value = o : t === "ref" ? (e.removeAttribute(t), r.signal && (r.value = e)) : a(e, t, o) }, { effect: !0 }) } function Y(e, t) { return document.createTreeWalker(e, 128, { acceptNode: r => r.textContent === t ? 1 : 2 }).nextNode() } function $(e, t, r = { 0: {} }) { if (!e) return console.error("MiNi: renderClient missing node element"); if (e.nodeType && (e = E(e)), typeof t == "function" && !t.html && (t = t()), typeof t == "function" && t.html && (t = t()), t.html === void 0) return console.error("MiNi: unknown input to renderClient", t); const { html: n, reactarray: a } = t, s = document.createElement("template"); s.innerHTML = n; const c = e.prev?.parentNode || e.parent; for (let o = 0; o < a.length; o++) { let i, { type: p, key: l, v: u } = a[o]; switch (p) { case "node": i = Y(s.content, "rx" + l), i ? typeof u == "function" ? I(i, u, r) : u instanceof Promise ? console.error("MiNi: wrap async component in ()=>{}") : u.html === !0 ? i = $(i, u, r) : console.error("MiNi: unknown node value", u) : console.error("MiNi: cannot find placeholder", "rx" + l, c); break; case "@": case ":": i = s.content.querySelector(`[${l + o}]`), i ? (i.removeAttribute(l + o), p === ":" ? X(i, l, u, r) : p === "@" ? i.addEventListener(l.toLowerCase(), u, l === "onwheel" ? { passive: !1 } : {}) : console.error("MiNi: unknown special attr", p, o)) : console.error("MiNi: cannot find attribute", l + o); break } } return w(e), e.next ? e.next.before(s.content) : c?.appendChild(s.content), e.destroy = () => { const o = T(r); o.length && o.forEach(i => typeof i == "function" && i()), C(r), w(e) }, e } async function D(e, t, r) { if (e.appendChild(document.createElement("div")), typeof t != "function") return console.error("MiNi: render 2nd arg must be a function"); let n = { 0: {} }; try { const a = await $(e.children[0], F`${() => t()}`, n); return r && console.log("rootowner", n), a } catch (a) { console.error("MiNi: render", a) } } export { O, F as W, D as f, z as o, Z as u };